# ================= BACKUP SELETIVO POR PALAVRAS-CHAVE (v2.4) =================
# Foco "Pastas": busca nomes de pastas e copia a PASTA INTEIRA (deepest only).
# Foco "Arquivos": busca nomes de arquivos e copia s√≥ os ARQUIVOS que casarem.
# √â C√ìPIA (n√£o apaga). Mant√©m estrutura relativa. Sem logs/CSV.
# -----------------------------------------------------------------------------

[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
$ErrorActionPreference = 'Stop'

function Info([string]$m){ Write-Host "[i] $m"  -ForegroundColor Cyan }
function Ok  ([string]$m){ Write-Host "[OK] $m" -ForegroundColor Green }
function Warn([string]$m){ Write-Host "[!] $m"  -ForegroundColor Yellow }
function Err ([string]$m){ Write-Host "[x] $m"  -ForegroundColor Red }

function Require-Path([string]$p,[string]$label){
  if([string]::IsNullOrWhiteSpace($p)){ throw "Caminho de $label n√£o informado." }
  (Resolve-Path -LiteralPath $p -ErrorAction Stop).Path.TrimEnd('\')
}
function Ensure-Dir([string]$p){
  if(-not (Test-Path -LiteralPath $p)){ New-Item -ItemType Directory -Path $p | Out-Null }
  (Resolve-Path -LiteralPath $p).Path.TrimEnd('\')
}
function ParseKeys([string]$raw){
  $k = $raw -split '[,\;\r\n]+' | ForEach-Object { $_.Trim() } | Where-Object { $_ }
  if($k.Count -eq 0){ throw "Nenhuma palavra-chave v√°lida informada." }
  $k | Sort-Object -Unique
}
function Pattern([string[]]$keys){ '(' + (($keys | ForEach-Object {[Regex]::Escape($_)}) -join '|') + ')' }
function AskYN([string]$q){ ($ans = Read-Host "$q (S/N)") -match '^[sS]' }
function AskFocus{
  do{
    $a = Read-Host "Foco da busca: [P]astas (copia pasta inteira) | [A]rquivos (s√≥ arquivos)"
    switch -Regex ($a){
      '^[pP]' { return 'Pastas' }
      '^[aA]' { return 'Arquivos' }
      default { Warn "Op√ß√£o inv√°lida. Use P ou A." }
    }
  } while ($true)
}

# Mant√©m apenas as PASTAS mais profundas (deepest) entre casadas aninhadas
function Keep-DeepestDirs([string[]]$dirPaths){
  $kept = New-Object System.Collections.Generic.List[string]
  foreach($cur in ($dirPaths | Sort-Object Length -Descending)){
    $isAncestorOfKept = $false
    foreach($k in $kept){ if($k.StartsWith($cur + '\')){ $isAncestorOfKept = $true; break } }
    if(-not $isAncestorOfKept){ [void]$kept.Add($cur) }
  }
  ,$kept
}

function ShowHeader{
  Clear-Host
  Write-Host "============== BACKUP SELETIVO POR PALAVRAS-CHAVE (v2.4) =======" -ForegroundColor Cyan
  Write-Host "Pastas -> copia pasta inteira (deepest).  Arquivos -> s√≥ arquivos."
  Write-Host "==============================================================="
}

function Run-Backup {
  ShowHeader

  $src = Read-Host "Informe a ORIGEM (ex.: C:\A)"
  $dst = Read-Host "Informe o DESTINO (ex.: C:\B)"
  $kw  = Read-Host "Informe as PALAVRAS-CHAVE (ex.: 1111,2222,3333)"
  $recurse = AskYN "Varrer subpastas?"
  $focus   = AskFocus

  try{
    $Source = Require-Path $src "Origem"
    $Dest   = Ensure-Dir   $dst
    $Keys   = ParseKeys $kw
    $Regex  = Pattern $Keys
    Ok ("Origem:  {0}" -f $Source)
    Ok ("Destino: {0}" -f $Dest)
    Ok ("Chaves:  {0}" -f ($Keys -join ', '))
    Ok ("Busca:   {0} | Foco: {1}" -f ($(if($recurse){'recursiva'}else{'n√≠vel atual'}), $focus))
  } catch { Err $_.Exception.Message; return }

  $errors = 0

  if($focus -eq 'Pastas'){
    # -------- Foco: PASTAS -> copia PASTA INTEIRA (deepest) --------
    $dirEnum = if($recurse){
      Get-ChildItem -LiteralPath $Source -Directory -Recurse -Force -ErrorAction SilentlyContinue
    } else {
      Get-ChildItem -LiteralPath $Source -Directory          -Force -ErrorAction SilentlyContinue
    }
    $matched = @($dirEnum | Where-Object { $_.Name -match $Regex } | Select-Object -ExpandProperty FullName)
    $deepest = Keep-DeepestDirs $matched

    Info ("Pastas casadas (deepest): {0}" -f $deepest.Count)
    if($deepest.Count -eq 0){ Warn "Nada para copiar."; return }
    if(-not (AskYN "Prosseguir com a C√ìPIA agora?")){ Warn "Opera√ß√£o cancelada."; return }

    $RobocopyExe = Join-Path $env:SystemRoot "System32\robocopy.exe"
    $roboArgs = @('/E','/COPY:DAT','/DCOPY:T','/Z','/R:1','/W:1','/MT:16','/XJ','/NFL','/NDL','/NP')

    foreach($d in $deepest){
      try{
        $rel    = $d.Substring($Source.Length).TrimStart('\')
        $dstDir = Join-Path $Dest $rel
        if(-not (Test-Path -LiteralPath $dstDir)){ New-Item -ItemType Directory -Path $dstDir -Force | Out-Null }
        Info ("Copiando PASTA inteira: {0}" -f $d)
        $null = & $RobocopyExe $d $dstDir @roboArgs
        if($LASTEXITCODE -ge 8){
          Warn ("Robocopy falhou (ExitCode={0}) em {1}; usando Copy-Item" -f $LASTEXITCODE, $d)
          Copy-Item -LiteralPath $d -Destination $dstDir -Recurse -Force -ErrorAction Stop
        } else { Ok ("Pasta conclu√≠da: {0}" -f $d) }
      } catch { $errors++; Err ("Falha em pasta '{0}': {1}" -f $d, $_.Exception.Message) }
    }
  }
  else {
    # -------- Foco: ARQUIVOS -> copia S√ì ARQUIVOS que casam --------
    $fileEnum = if($recurse){
      Get-ChildItem -LiteralPath $Source -File -Recurse -Force -ErrorAction SilentlyContinue
    } else {
      Get-ChildItem -LiteralPath $Source -File          -Force -ErrorAction SilentlyContinue
    }
    $files = @($fileEnum | Where-Object { $_.Name -match $Regex })

    Info ("Arquivos que casam: {0}" -f $files.Count)
    if($files.Count -eq 0){ Warn "Nada para copiar."; return }
    if(-not (AskYN "Prosseguir com a C√ìPIA agora?")){ Warn "Opera√ß√£o cancelada."; return }

    foreach($f in $files){
      try{
        $rel    = $f.FullName.Substring($Source.Length).TrimStart('\')
        $subRel = Split-Path -Path $rel -Parent
        $dstDir = if([string]::IsNullOrEmpty($subRel)){ $Dest } else { Join-Path $Dest $subRel }
        if(-not (Test-Path -LiteralPath $dstDir)){ New-Item -ItemType Directory -Path $dstDir -Force | Out-Null }
        Copy-Item -LiteralPath $f.FullName -Destination $dstDir -Force -ErrorAction Stop
        Ok ("Arquivo copiado: {0}" -f $f.FullName)
      } catch { $errors++; Err ("Falha '{0}': {1}" -f $f.FullName, $_.Exception.Message) }
    }
  }

  if($errors -gt 0){ Warn ("Finalizado com {0} falha(s)." -f $errors) } else { Ok "Conclu√≠do sem falhas. üéâ" }
}

# ---------------- Menu ----------------
do {
  try {
    ShowHeader
    Write-Host "[1] Executar backup seletivo (interativo)" -ForegroundColor Green
    Write-Host "[0] Sair"
    Write-Host "==============================================================="
    $opt = Read-Host "Escolha uma op√ß√£o"
    switch($opt){
      '1' { Run-Backup }
      '0' {
           Info "Saindo..."
           Start-Sleep -Milliseconds 120
           exit 0                 # fecha o processo do PowerShell
      }
      default { Warn "Op√ß√£o inv√°lida." }
    }
    if($opt -ne '0'){
      Info "Pressione Enter para voltar ao menu..."
      [void][System.Console]::ReadLine()
    }
  } catch {
    Err ("Erro: {0}" -f $_.Exception.Message)
    Info "Pressione Enter para continuar..."
    [void][System.Console]::ReadLine()
  }
} while ($true)
# ============================================================================
