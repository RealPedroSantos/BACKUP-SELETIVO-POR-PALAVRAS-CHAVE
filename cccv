# ======================= BACKUP SELETIVO POR PALAVRAS-CHAVE (v2.3) =======================
# Padr√£o: ESTRITO -> copia APENAS itens cujo NOME cont√©m alguma chave.
# Extra:  PASTA=TUDO -> se a pasta casa, copia TUDO que h√° dentro dela.
# √â C√ìPIA (n√£o apaga). Mant√©m estrutura relativa. Sem logs/CSV.
# -----------------------------------------------------------------------------------------

[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
$ErrorActionPreference = 'Stop'

function Info([string]$m){ Write-Host "[i] $m"  -ForegroundColor Cyan }
function Ok  ([string]$m){ Write-Host "[OK] $m" -ForegroundColor Green }
function Warn([string]$m){ Write-Host "[!] $m"  -ForegroundColor Yellow }
function Err ([string]$m){ Write-Host "[x] $m"  -ForegroundColor Red }

function Require-Path([string]$p,[string]$label){
  if([string]::IsNullOrWhiteSpace($p)){ throw "Caminho de $label n√£o informado." }
  (Resolve-Path -LiteralPath $p -ErrorAction Stop).Path.TrimEnd('\')
}
function Ensure-Dir([string]$p){
  if(-not (Test-Path -LiteralPath $p)){ New-Item -ItemType Directory -Path $p | Out-Null }
  (Resolve-Path -LiteralPath $p).Path.TrimEnd('\')
}
function ParseKeys([string]$raw){
  $k = $raw -split '[,\;\r\n]+' | ForEach-Object { $_.Trim() } | Where-Object { $_ }
  if($k.Count -eq 0){ throw "Nenhuma palavra-chave v√°lida informada." }
  $k | Sort-Object -Unique
}
function Pattern([string[]]$keys){ '(' + (($keys | ForEach-Object {[Regex]::Escape($_)}) -join '|') + ')' }
function AskYN([string]$q){ ($ans = Read-Host "$q (S/N)") -match '^[sS]' }

function ShowHeader{
  Clear-Host
  Write-Host "============== BACKUP SELETIVO POR PALAVRAS-CHAVE (v2.3) =======" -ForegroundColor Cyan
  Write-Host "Modo padr√£o: ESTRITO (copia s√≥ itens com a chave no NOME)."
  Write-Host "Extra: PASTA=TUDO (se a pasta casa, leva tudo dentro)."
  Write-Host "==============================================================="
}

function Keep-TopMostDirs([string[]]$dirPaths){
  $kept = New-Object System.Collections.Generic.List[string]
  foreach($cur in ($dirPaths | Sort-Object Length)){
    if(-not ($kept | Where-Object { $cur.StartsWith($_ + '\') -or $cur -eq $_ })){
      [void]$kept.Add($cur)
    }
  }
  $kept
}

function Run-Backup {
  ShowHeader

  $src = Read-Host "Informe a ORIGEM (ex.: C:\A)"
  $dst = Read-Host "Informe o DESTINO (ex.: C:\B)"
  $kw  = Read-Host "Informe as PALAVRAS-CHAVE (ex.: 1111,2222,3333)"

  $recurse = AskYN "Varrer subpastas?"
  $strict  = AskYN "Modo ESTRITO (copiar APENAS itens cujo NOME casa)?"

  try{
    $Source = Require-Path $src "Origem"
    $Dest   = Ensure-Dir   $dst
    $Keys   = ParseKeys $kw
    $Regex  = Pattern $Keys
    Ok "Origem:  $Source"
    Ok "Destino: $Dest"
    Ok "Chaves:  $($Keys -join ', ')"
    Ok ("Busca:  {0} | Modo: {1}" -f ($(if($recurse){'recursiva'}else{'n√≠vel atual'}), $(if($strict){'Estrito'}else{'Pasta=Tudo'})))
  } catch { Err $_.Exception.Message; return }

  $errors = 0

  if($strict){
    # -------- MODO ESTRITO --------
    $dirEnum = if($recurse){ Get-ChildItem -LiteralPath $Source -Directory -Recurse -Force -ErrorAction SilentlyContinue }
               else         { Get-ChildItem -LiteralPath $Source -Directory          -Force -ErrorAction SilentlyContinue }
    $fileEnum = if($recurse){ Get-ChildItem -LiteralPath $Source -File -Recurse -Force -ErrorAction SilentlyContinue }
                else         { Get-ChildItem -LiteralPath $Source -File          -Force -ErrorAction SilentlyContinue }

    $dirs  = @($dirEnum  | Where-Object { $_.Name -match $Regex })
    $files = @($fileEnum | Where-Object { $_.Name -match $Regex })

    $dirRel = $dirs | ForEach-Object { $_.FullName.Substring($Source.Length).TrimStart('\') } | Sort-Object -Unique

    Info ("Pastas que casam: {0} | Arquivos que casam: {1}" -f $dirRel.Count, $files.Count)
    if($dirRel.Count -eq 0 -and $files.Count -eq 0){ Warn "Nada para copiar."; return }
    if(-not (AskYN "Prosseguir com a C√ìPIA agora?")){ Warn "Opera√ß√£o cancelada."; return }

    foreach($rel in $dirRel){
      try{
        $dstDir = Join-Path $Dest $rel
        New-Item -ItemType Directory -Path $dstDir -Force | Out-Null
        Ok "Pasta criada (estrutura): $dstDir"
      } catch { $errors++; Err "Falha ao criar pasta '$rel': $($_.Exception.Message)" }
    }

    foreach($f in $files){
      try{
        $rel    = $f.FullName.Substring($Source.Length).TrimStart('\')
        $subRel = Split-Path -Path $rel -Parent
        $dstDir = if([string]::IsNullOrEmpty($subRel)){ $Dest } else { Join-Path $Dest $subRel }
        if(-not (Test-Path -LiteralPath $dstDir)){ New-Item -ItemType Directory -Path $dstDir -Force | Out-Null }
        Copy-Item -LiteralPath $f.FullName -Destination $dstDir -Force -ErrorAction Stop
        Ok "Arquivo copiado: $($f.FullName)"
      } catch { $errors++; Err "Falha '$($f.FullName)': $($_.Exception.Message)" }
    }
  }
  else{
    # -------- MODO PASTA=TUDO --------
    $dirEnum = if($recurse){ Get-ChildItem -LiteralPath $Source -Directory -Recurse -Force -ErrorAction SilentlyContinue }
               else         { Get-ChildItem -LiteralPath $Source -Directory          -Force -ErrorAction SilentlyContinue }
    $matchedDirs = @($dirEnum | Where-Object { $_.Name -match $Regex })
    $dirTop = Keep-TopMostDirs (@($matchedDirs | Select-Object -ExpandProperty FullName))

    $fileEnum = if($recurse){ Get-ChildItem -LiteralPath $Source -File -Recurse -Force -ErrorAction SilentlyContinue }
                else         { Get-ChildItem -LiteralPath $Source -File          -Force -ErrorAction SilentlyContinue }
    $matchedFiles = @($fileEnum | Where-Object { $_.Name -match $Regex })

    $dirSet = [System.Collections.Generic.HashSet[string]]::new([StringComparer]::OrdinalIgnoreCase)
    foreach($d in $dirTop){ [void]$dirSet.Add($d) }

    $filesOutside = @(
      foreach($f in $matchedFiles){
        $covered = $false
        foreach($d in $dirSet){ if($f.FullName.StartsWith($d + '\')){ $covered = $true; break } }
        if(-not $covered){ $f }
      }
    )

    Info ("Pastas inteiras: {0} | Arquivos isolados: {1}" -f $dirTop.Count, $filesOutside.Count)
    if($dirTop.Count -eq 0 -and $filesOutside.Count -eq 0){ Warn "Nada para copiar."; return }
    if(-not (AskYN "Prosseguir com a C√ìPIA agora?")){ Warn "Opera√ß√£o cancelada."; return }

    $RobocopyExe = Join-Path $env:SystemRoot "System32\robocopy.exe"
    $roboArgs = @('/E','/COPY:DAT','/DCOPY:T','/Z','/R:1','/W:1','/MT:16','/XJ','/NFL','/NDL','/NP')

    foreach($d in $dirTop){
      try{
        $rel    = $d.Substring($Source.Length).TrimStart('\')
        $dstDir = Join-Path $Dest $rel
        if(-not (Test-Path -LiteralPath $dstDir)){ New-Item -ItemType Directory -Path $dstDir -Force | Out-Null }
        Info "Copiando PASTA inteira: $d"
        $null = & $RobocopyExe $d $dstDir @roboArgs
        if($LASTEXITCODE -ge 8){
          Warn "Robocopy falhou (ExitCode=$LASTEXITCODE) em $d; usando Copy-Item"
          Copy-Item -LiteralPath $d -Destination $dstDir -Recurse -Force -ErrorAction Stop
        } else { Ok "Pasta conclu√≠da: $d" }
      } catch { $errors++; Err "Falha em pasta '$d': $($_.Exception.Message)" }
    }

    foreach($f in $filesOutside){
      try{
        $rel    = $f.FullName.Substring($Source.Length).TrimStart('\')
        $subRel = Split-Path -Path $rel -Parent
        $dstDir = if([string]::IsNullOrEmpty($subRel)){ $Dest } else { Join-Path $Dest $subRel }
        if(-not (Test-Path -LiteralPath $dstDir)){ New-Item -ItemType Directory -Path $dstDir -Force | Out-Null }
        Copy-Item -LiteralPath $f.FullName -Destination $dstDir -Force -ErrorAction Stop
        Ok "Arquivo isolado copiado: $($f.FullName)"
      } catch { $errors++; Err "Falha '$($f.FullName)': $($_.Exception.Message)" }
    }
  }

  if($errors -gt 0){ Warn "Finalizado com $errors falha(s)." } else { Ok "Conclu√≠do sem falhas. üéâ" }
}

# -------- Menu --------
do {
  try {
    ShowHeader
    Write-Host "[1] Executar backup seletivo (interativo)" -ForegroundColor Green
    Write-Host "[0] Sair"
    Write-Host "==============================================================="
    $opt = Read-Host "Escolha uma op√ß√£o"
    switch($opt){
      '1' { Run-Backup }
      '0' { break }
      default { Warn "Op√ß√£o inv√°lida." }
    }
    if($opt -ne '0'){ Info "Pressione Enter para voltar ao menu..."; [void][System.Console]::ReadLine() }
  } catch {
    Err "Erro: $($_.Exception.Message)"
    Info "Pressione Enter para continuar..."
    [void][System.Console]::ReadLine()
  }
} while ($true)
# =========================================================================================
