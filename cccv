# ============== SELETOR POR PALAVRAS-CHAVE (CÃ³pia/ExclusÃ£o/ConferÃªncia) v3.3 ==============

[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
$ErrorActionPreference = 'Stop'

# ---------------- Utilidades comuns ----------------
function Info([string]$m){ Write-Host "[i] $m"  -ForegroundColor Cyan }
function Ok  ([string]$m){ Write-Host "[OK] $m" -ForegroundColor Green }
function Warn([string]$m){ Write-Host "[!] $m"  -ForegroundColor Yellow }
function Err ([string]$m){ Write-Host "[x] $m"  -ForegroundColor Red }

function Require-Path([string]$p,[string]$label){
  if([string]::IsNullOrWhiteSpace($p)){ throw "Caminho de $label nÃ£o informado." }
  $resolved = (Resolve-Path -LiteralPath $p -ErrorAction Stop).Path
  return $resolved.TrimEnd('\')
}
function Ensure-Dir([string]$p){
  if(-not (Test-Path -LiteralPath $p)){ New-Item -ItemType Directory -Path $p | Out-Null }
  (Resolve-Path -LiteralPath $p).Path.TrimEnd('\')
}
function ParseKeys([string]$raw){
  $k = $raw -split '[,\r\n;]+' | ForEach-Object { $_.Trim() } | Where-Object { $_ }
  if($k.Count -eq 0){ throw "Nenhuma palavra-chave vÃ¡lida informada." }
  $k | Sort-Object -Unique
}
function Pattern([string[]]$keys){ '(' + (($keys | ForEach-Object {[Regex]::Escape($_)}) -join '|') + ')' }

# Pastas: usar sÃ³ os 4 primeiros caracteres do nome
function First4([string]$s){
  if([string]::IsNullOrEmpty($s)){ return "" }
  $len = [Math]::Min(4, $s.Length)
  return $s.Substring(0, $len)
}

# Pastas: CHAVE deve estar nos 4 primeiros chars e NÃƒO pode continuar com letra/dÃ­gito.
# Ex.: chave '121' casa em '121 ' ou '121-' etc.; NÃƒO casa em '1213'.
function PatternPrefixToken([string[]]$keys){
  $union = ($keys | ForEach-Object {[Regex]::Escape($_)}) -join '|'
  return '^(?:' + $union + ')(?![0-9A-Za-z])'
}

function AskYN([string]$q){ ($ans = Read-Host "$q (S/N)") -match '^[sS]' }

function AskFocus([string]$acao){
  do{
    $txt = if($acao -eq 'Apagar'){
      "Foco: [P]astas (apaga pasta inteira) | [A]rquivos (sÃ³ arquivos)"
    } else {
      "Foco da busca: [P]astas (copia pasta inteira) | [A]rquivos (sÃ³ arquivos)"
    }
    $a = Read-Host $txt
    switch -Regex ($a){
      '^[pP]' { return 'Pastas' }
      '^[aA]' { return 'Arquivos' }
      default { Warn "OpÃ§Ã£o invÃ¡lida. Use P ou A." }
    }
  } while ($true)
}

function AskScopeCheck{
  do{
    $a = Read-Host "Escopo: [P]astas | [A]rquivos | [B]oth (ambos)"
    switch -Regex ($a){
      '^[pP]' { return 'Pastas' }
      '^[aA]' { return 'Arquivos' }
      '^[bB]' { return 'Ambos' }
      default { Warn "OpÃ§Ã£o invÃ¡lida. Use P, A ou B." }
    }
  } while ($true)
}

# MantÃ©m apenas as PASTAS mais profundas (deepest)
function Keep-DeepestDirs([string[]]$dirPaths){
  $kept = New-Object System.Collections.Generic.List[string]
  foreach($cur in ($dirPaths | Sort-Object Length -Descending)){
    $isAncestorOfKept = $false
    foreach($k in $kept){ if($k.StartsWith($cur + '\')){ $isAncestorOfKept = $true; break } }
    if(-not $isAncestorOfKept){ [void]$kept.Add($cur) }
  }
  ,$kept
}

# ---------------- CabeÃ§alhos ----------------
function ShowHeaderMain{
  Clear-Host
  Write-Host "================ SELETOR POR PALAVRAS-CHAVE (v3.3) ================" -ForegroundColor Cyan
  Write-Host "[1] Copiar (backup seletivo)" -ForegroundColor Green
  Write-Host "[2] Excluir (apagamento seletivo - permanente)" -ForegroundColor Yellow
  Write-Host "[3] Conferir (verificar chaves presentes/ausentes)" -ForegroundColor Magenta
  Write-Host "[0] Sair"
  Write-Host "===================================================================="
}
function ShowHeaderCopy{
  Clear-Host
  Write-Host "============== BACKUP SELETIVO POR PALAVRAS-CHAVE (v2.4) =======" -ForegroundColor Cyan
  Write-Host "Pastas -> sÃ³ 4 primeiros chars (com limite de token).  Arquivos -> nome inteiro."
  Write-Host "==============================================================="
}
function ShowHeaderDelete{
  Clear-Host
  Write-Host "========== EXCLUSÃƒO SELETIVA POR PALAVRAS-CHAVE (v2.4) =========" -ForegroundColor Cyan
  Write-Host "Pastas -> sÃ³ 4 primeiros chars (com limite de token).  Arquivos -> nome inteiro."
  Write-Host "AÃ‡ÃƒO DESTRUTIVA! Sem lixeira. Confirme com atenÃ§Ã£o." -ForegroundColor Yellow
  Write-Host "==============================================================="
}
function ShowHeaderCheck{
  Clear-Host
  Write-Host "================ CONFERÃŠNCIA POR PALAVRAS-CHAVE (v1.2) =================" -ForegroundColor Cyan
  Write-Host "Pastas: confere sÃ³ os 4 primeiros chars com limite de token. Arquivos: nome inteiro."
  Write-Host "Mostra chaves ENCONTRADAS e NÃƒO ENCONTRADAS (com amostras opcionais)."
  Write-Host "========================================================================"
}

# ---------------- Programa 1: COPIAR ----------------
function Run-Backup {
  ShowHeaderCopy

  $src = Read-Host "Informe a ORIGEM (ex.: C:\A)"
  $dst = Read-Host "Informe o DESTINO (ex.: C:\B)"
  $kw  = Read-Host "Informe as PALAVRAS-CHAVE (ex.: 1111,2222,3333)"
  $recurse = AskYN "Varrer subpastas?"
  $focus   = AskFocus 'Copiar'

  try{
    $Source = Require-Path $src "Origem"
    $Dest   = Ensure-Dir   $dst
    $Keys   = ParseKeys $kw
    $RegexAny   = Pattern $Keys
    $RegexPfxTk = PatternPrefixToken $Keys
    Ok ("Origem:  {0}" -f $Source)
    Ok ("Destino: {0}" -f $Dest)
    Ok ("Chaves:  {0}" -f ($Keys -join ', '))
    Ok ("Busca:   {0} | Foco: {1}" -f ($(if($recurse){'recursiva'}else{'nÃ­vel atual'}), $focus))
  } catch { Err $_.Exception.Message; return }

  $errors = 0

  if($focus -eq 'Pastas'){
    # PASTAS -> casa SOMENTE nos 4 primeiros chars com limite de token
    $dirEnum = if($recurse){
      Get-ChildItem -LiteralPath $Source -Directory -Recurse -Force -ErrorAction SilentlyContinue
    } else {
      Get-ChildItem -LiteralPath $Source -Directory          -Force -ErrorAction SilentlyContinue
    }
    $matched = @(
      $dirEnum |
      Where-Object { (First4 $_.Name) -match $RegexPfxTk } |
      Select-Object -ExpandProperty FullName
    )
    $deepest = Keep-DeepestDirs $matched

    Info ("Pastas casadas (deepest): {0}" -f $deepest.Count)
    if($deepest.Count -eq 0){ Warn "Nada para copiar."; return }
    if(-not (AskYN "Prosseguir com a CÃ“PIA agora?")){ Warn "OperaÃ§Ã£o cancelada."; return }

    $RobocopyExe = Join-Path $env:SystemRoot "System32\robocopy.exe"
    $roboArgs = @('/E','/COPY:DAT','/DCOPY:T','/Z','/R:1','/W:1','/MT:16','/XJ','/NFL','/NDL','/NP')

    foreach($d in $deepest){
      try{
        $rel    = $d.Substring($Source.Length).TrimStart('\')
        $dstDir = Join-Path $Dest $rel
        if(-not (Test-Path -LiteralPath $dstDir)){ New-Item -ItemType Directory -Path $dstDir -Force | Out-Null }
        Info ("Copiando PASTA inteira: {0}" -f $d)
        $null = & $RobocopyExe $d $dstDir @roboArgs
        if($LASTEXITCODE -ge 8){
          Warn ("Robocopy falhou (ExitCode={0}) em {1}; usando Copy-Item" -f $LASTEXITCODE, $d)
          Copy-Item -LiteralPath $d -Destination $dstDir -Recurse -Force -ErrorAction Stop
        } else { Ok ("Pasta concluÃ­da: {0}" -f $d) }
      } catch { $errors++; Err ("Falha em pasta '{0}': {1}" -f $d, $_.Exception.Message) }
    }
  }
  else {
    # ARQUIVOS -> nome inteiro
    $fileEnum = if($recurse){
      Get-ChildItem -LiteralPath $Source -File -Recurse -Force -ErrorAction SilentlyContinue
    } else {
      Get-ChildItem -LiteralPath $Source -File          -Force -ErrorAction SilentlyContinue
    }
    $files = @($fileEnum | Where-Object { $_.Name -match $RegexAny })

    Info ("Arquivos que casam: {0}" -f $files.Count)
    if($files.Count -eq 0){ Warn "Nada para copiar."; return }
    if(-not (AskYN "Prosseguir com a CÃ“PIA agora?")){ Warn "OperaÃ§Ã£o cancelada."; return }

    foreach($f in $files){
      try{
        $rel    = $f.FullName.Substring($Source.Length).TrimStart('\')
        $subRel = Split-Path -Path $rel -Parent
        $dstDir = if([string]::IsNullOrEmpty($subRel)){ $Dest } else { Join-Path $Dest $subRel }
        if(-not (Test-Path -LiteralPath $dstDir)){ New-Item -ItemType Directory -Path $dstDir -Force | Out-Null }
        Copy-Item -LiteralPath $f.FullName -Destination $dstDir -Force -ErrorAction Stop
        Ok ("Arquivo copiado: {0}" -f $f.FullName)
      } catch { $errors++; Err ("Falha '{0}': {1}" -f $f.FullName, $_.Exception.Message) }
    }
  }

  if($errors -gt 0){ Warn ("Finalizado com {0} falha(s)." -f $errors) } else { Ok "ConcluÃ­do sem falhas. ðŸŽ‰" }
}

# ---------------- Programa 2: EXCLUIR ----------------
function Confirm-Deletion([int]$qtdPastas,[int]$qtdArquivos){
  Write-Host ""
  Write-Host ("Resumo: Pastas a apagar: {0} | Arquivos a apagar: {1}" -f $qtdPastas,$qtdArquivos) -ForegroundColor Yellow
  return (AskYN "Prosseguir com a EXCLUSÃƒO agora?")
}

function Run-Delete {
  ShowHeaderDelete

  $src = Read-Host "Informe a ORIGEM (ex.: C:\A)"
  $kw  = Read-Host "Informe as PALAVRAS-CHAVE (ex.: 1111,2222,3333)"
  $recurse = AskYN "Varrer subpastas?"
  $focus   = AskFocus 'Apagar'

  try{
    $Source = Require-Path $src "Origem"
    $Keys   = ParseKeys $kw
    $RegexAny   = Pattern $Keys
    $RegexPfxTk = PatternPrefixToken $Keys
    Info ("Origem:  {0}" -f $Source)
    Info ("Chaves:  {0}" -f ($Keys -join ', '))
    Info ("Busca:   {0} | Foco: {1}" -f ($(if($recurse){'recursiva'}else{'nÃ­vel atual'}), $focus))
  } catch { Err $_.Exception.Message; return }

  $errors = 0

  if($focus -eq 'Pastas'){
    $dirEnum = if($recurse){
      Get-ChildItem -LiteralPath $Source -Directory -Recurse -Force -ErrorAction SilentlyContinue
    } else {
      Get-ChildItem -LiteralPath $Source -Directory          -Force -ErrorAction SilentlyContinue
    }
    $matched = @(
      $dirEnum |
      Where-Object { (First4 $_.Name) -match $RegexPfxTk } |
      Select-Object -ExpandProperty FullName
    )
    $deepest = Keep-DeepestDirs $matched

    Info ("Pastas casadas (deepest): {0}" -f $deepest.Count)
    if($deepest.Count -eq 0){ Warn "Nada para apagar."; return }

    if(-not (Confirm-Deletion -qtdPastas $deepest.Count -qtdArquivos 0)){
      Warn "OperaÃ§Ã£o cancelada."; return
    }

    foreach($d in $deepest){
      try{
        Write-Host ("Apagando PASTA: {0}" -f $d)
        Remove-Item -LiteralPath $d -Recurse -Force -ErrorAction Stop
        Ok ("Pasta apagada: {0}" -f $d)
      } catch { $errors++; Err ("Falha ao apagar pasta '{0}': {1}" -f $d, $_.Exception.Message) }
    }
  }
  else {
    $fileEnum = if($recurse){
      Get-ChildItem -LiteralPath $Source -File -Recurse -Force -ErrorAction SilentlyContinue
    } else {
      Get-ChildItem -LiteralPath $Source -File          -Force -ErrorAction SilentlyContinue
    }
    $files = @($fileEnum | Where-Object { $_.Name -match $RegexAny })

    Info ("Arquivos que casam: {0}" -f $files.Count)
    if($files.Count -eq 0){ Warn "Nada para apagar."; return }

    if(-not (Confirm-Deletion -qtdPastas 0 -qtdArquivos $files.Count)){
      Warn "OperaÃ§Ã£o cancelada."; return
    }

    foreach($f in $files){
      try{
        Write-Host ("Apagando ARQUIVO: {0}" -f $f.FullName)
        Remove-Item -LiteralPath $f.FullName -Force -ErrorAction Stop
        Ok ("Arquivo apagado: {0}" -f $f.FullName)
      } catch { $errors++; Err ("Falha ao apagar '{0}': {1}" -f $f.FullName, $_.Exception.Message) }
    }
  }

  if($errors -gt 0){ Warn ("Finalizado com {0} falha(s)." -f $errors) } else { Ok "ConcluÃ­do sem falhas. ðŸŽ‰" }
}

# ---------------- Programa 3: CONFERIR ----------------
function Run-Check {
  ShowHeaderCheck

  $path = Read-Host "Informe o CAMINHO a conferir (ex.: C:\Destino)"
  $kw   = Read-Host "Informe as PALAVRAS-CHAVE (ex.: 1111,2222,3333)"
  $recurse = AskYN "Varrer subpastas?"
  $scope   = AskScopeCheck

  try{
    $Base   = Require-Path $path "Caminho"
    $Keys   = ParseKeys $kw
    $RegexAny = Pattern $Keys
    Ok ("Caminho: {0}" -f $Base)
    Ok ("Chaves:  {0}" -f ($Keys -join ', '))
    Ok ("Busca:   {0} | Escopo: {1}" -f ($(if($recurse){'recursiva'}else{'nÃ­vel atual'}), $scope))
  } catch { Err $_.Exception.Message; return }

  $dirs  = @()
  $files = @()
  if($scope -in @('Pastas','Ambos')){
    $dirs = if($recurse){
      Get-ChildItem -LiteralPath $Base -Directory -Recurse -Force -ErrorAction SilentlyContinue
    } else {
      Get-ChildItem -LiteralPath $Base -Directory          -Force -ErrorAction SilentlyContinue
    }
  }
  if($scope -in @('Arquivos','Ambos')){
    $files = if($recurse){
      Get-ChildItem -LiteralPath $Base -File -Recurse -Force -ErrorAction SilentlyContinue
    } else {
      Get-ChildItem -LiteralPath $Base -File          -Force -ErrorAction SilentlyContinue
    }
  }

  if(($scope -eq 'Pastas' -or $scope -eq 'Ambos') -and -not $dirs){ Warn "Nenhuma pasta encontrada no escopo/recursÃ£o definidos." }
  if(($scope -eq 'Arquivos' -or $scope -eq 'Ambos') -and -not $files){ Warn "Nenhum arquivo encontrado no escopo/recursÃ£o definidos." }
  if(-not $dirs -and -not $files){ return }

  $foundKeys   = New-Object System.Collections.Generic.List[string]
  $missingKeys = New-Object System.Collections.Generic.List[string]
  $samplesByKey = @{}

  foreach($k in $Keys){
    $rx = [Regex]::Escape($k)
    $rxPrefix = '^' + $rx + '(?![0-9A-Za-z])'  # limite de token nos 4 primeiros chars

    $dirHits = @()
    if($dirs){
      $dirHits = $dirs | Where-Object { (First4 $_.Name) -match $rxPrefix } | Select-Object -ExpandProperty Name
    }

    $fileHits = @()
    if($files){
      $fileHits = $files | Where-Object { $_.Name -match $rx } | Select-Object -ExpandProperty Name
    }

    $hits = @($dirHits + $fileHits)
    if($hits.Count -gt 0){
      [void]$foundKeys.Add($k)
      $samplesByKey[$k] = ($hits | Select-Object -Unique -First 10)
    } else {
      [void]$missingKeys.Add($k)
    }
  }

  Write-Host ""
  Write-Host "==================== RESULTADO DA CONFERÃŠNCIA ====================" -ForegroundColor Magenta
  Write-Host ("Chaves ENCONTRADAS: {0}" -f $foundKeys.Count) -ForegroundColor Green
  if($foundKeys.Count -gt 0){ Write-Host (" - {0}" -f ($foundKeys -join ', ')) -ForegroundColor DarkGreen }
  Write-Host ("Chaves NÃƒO ENCONTRADAS: {0}" -f $missingKeys.Count) -ForegroundColor Yellow
  if($missingKeys.Count -gt 0){ Write-Host (" - {0}" -f ($missingKeys -join ', ')) -ForegroundColor DarkYellow }

  if(($foundKeys.Count -gt 0) -and (AskYN "Deseja ver AMOSTRAS de itens casados por chave?")){
    foreach($k in $foundKeys){
      Write-Host ("--- Amostras para chave '{0}':" -f $k) -ForegroundColor Cyan
      foreach($s in $samplesByKey[$k]){ Write-Host ("   â€¢ {0}" -f $s) }
    }
  }

  Ok "ConferÃªncia concluÃ­da. âœ…"
}

# ---------------- Menu principal ----------------
do {
  try {
    ShowHeaderMain
    $opt = Read-Host "Escolha uma opÃ§Ã£o"
    switch($opt){
      '1' { Run-Backup }
      '2' { Run-Delete }
      '3' { Run-Check  }
      '0' {
        Info "Saindo..."
        Start-Sleep -Milliseconds 120
        exit 0
      }
      default { Warn "OpÃ§Ã£o invÃ¡lida." }
    }
    if($opt -notin @('0')){
      Info "Pressione Enter para voltar ao menu..."
      [void][System.Console]::ReadLine()
    }
  } catch {
    Err ("Erro: {0}" -f $_.Exception.Message)
    Info "Pressione Enter para continuar..."
    [void][System.Console]::ReadLine()
  }
} while ($true)

# ===========================================================================================
