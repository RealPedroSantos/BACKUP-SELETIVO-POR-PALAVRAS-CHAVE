# ============== SELETOR POR PALAVRAS-CHAVE (C√≥pia/Exclus√£o) v3.0 ==============
# [1] Copiar:  Foco "Pastas" -> copia PASTA INTEIRA (deepest) | "Arquivos" -> s√≥ os arquivos
# [2] Excluir: Foco "Pastas" -> apaga PASTA INTEIRA (deepest) | "Arquivos" -> s√≥ os arquivos
# √â C√ìPIA (n√£o apaga) no modo 1. Exclus√£o √© permanente no modo 2 (sem lixeira).
# ==============================================================================

[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
$ErrorActionPreference = 'Stop'

# ---------------- Utilidades comuns ----------------
function Info([string]$m){ Write-Host "[i] $m"  -ForegroundColor Cyan }
function Ok  ([string]$m){ Write-Host "[OK] $m" -ForegroundColor Green }
function Warn([string]$m){ Write-Host "[!] $m"  -ForegroundColor Yellow }
function Err ([string]$m){ Write-Host "[x] $m"  -ForegroundColor Red }

function Require-Path([string]$p,[string]$label){
  if([string]::IsNullOrWhiteSpace($p)){ throw "Caminho de $label n√£o informado." }
  (Resolve-Path -LiteralPath $p -ErrorAction Stop).Path.TrimEnd('\')
}
function Ensure-Dir([string]$p){
  if(-not (Test-Path -LiteralPath $p)){ New-Item -ItemType Directory -Path $p | Out-Null }
  (Resolve-Path -LiteralPath $p).Path.TrimEnd('\')
}
function ParseKeys([string]$raw){
  $k = $raw -split '[,\;\r\n]+' | ForEach-Object { $_.Trim() } | Where-Object { $_ }
  if($k.Count -eq 0){ throw "Nenhuma palavra-chave v√°lida informada." }
  $k | Sort-Object -Unique
}
function Pattern([string[]]$keys){ '(' + (($keys | ForEach-Object {[Regex]::Escape($_)}) -join '|') + ')' }
function AskYN([string]$q){ ($ans = Read-Host "$q (S/N)") -match '^[sS]' }

# Foco com prompt ajustado por a√ß√£o
function AskFocus([string]$acao){
  do{
    $txt = if($acao -eq 'Apagar'){
      "Foco: [P]astas (apaga pasta inteira) | [A]rquivos (s√≥ arquivos)"
    } else {
      "Foco da busca: [P]astas (copia pasta inteira) | [A]rquivos (s√≥ arquivos)"
    }
    $a = Read-Host $txt
    switch -Regex ($a){
      '^[pP]' { return 'Pastas' }
      '^[aA]' { return 'Arquivos' }
      default { Warn "Op√ß√£o inv√°lida. Use P ou A." }
    }
  } while ($true)
}

# Mant√©m apenas as PASTAS mais profundas (deepest) entre casadas aninhadas
function Keep-DeepestDirs([string[]]$dirPaths){
  $kept = New-Object System.Collections.Generic.List[string]
  foreach($cur in ($dirPaths | Sort-Object Length -Descending)){
    $isAncestorOfKept = $false
    foreach($k in $kept){ if($k.StartsWith($cur + '\')){ $isAncestorOfKept = $true; break } }
    if(-not $isAncestorOfKept){ [void]$kept.Add($cur) }
  }
  ,$kept
}

# ---------------- Cabe√ßalhos ----------------
function ShowHeaderMain{
  Clear-Host
  Write-Host "================ SELETOR POR PALAVRAS-CHAVE (v3.0) ================" -ForegroundColor Cyan
  Write-Host "[1] Copiar (backup seletivo)" -ForegroundColor Green
  Write-Host "[2] Excluir (apagamento seletivo - permanente)" -ForegroundColor Yellow
  Write-Host "[0] Sair"
  Write-Host "===================================================================="
}
function ShowHeaderCopy{
  Clear-Host
  Write-Host "============== BACKUP SELETIVO POR PALAVRAS-CHAVE (v2.4) =======" -ForegroundColor Cyan
  Write-Host "Pastas -> copia pasta inteira (deepest).  Arquivos -> s√≥ arquivos."
  Write-Host "==============================================================="
}
function ShowHeaderDelete{
  Clear-Host
  Write-Host "========== EXCLUS√ÉO SELETIVA POR PALAVRAS-CHAVE (v2.4) =========" -ForegroundColor Cyan
  Write-Host "Pastas -> APAGA pasta inteira (deepest).  Arquivos -> APAGA s√≥ arquivos."
  Write-Host "A√á√ÉO DESTRUTIVA! Sem lixeira. Confirme com aten√ß√£o." -ForegroundColor Yellow
  Write-Host "==============================================================="
}

# ---------------- Programa 1: COPIAR ----------------
function Run-Backup {
  ShowHeaderCopy

  $src = Read-Host "Informe a ORIGEM (ex.: C:\A)"
  $dst = Read-Host "Informe o DESTINO (ex.: C:\B)"
  $kw  = Read-Host "Informe as PALAVRAS-CHAVE (ex.: 1111,2222,3333)"
  $recurse = AskYN "Varrer subpastas?"
  $focus   = AskFocus 'Copiar'

  try{
    $Source = Require-Path $src "Origem"
    $Dest   = Ensure-Dir   $dst
    $Keys   = ParseKeys $kw
    $Regex  = Pattern $Keys
    Ok ("Origem:  {0}" -f $Source)
    Ok ("Destino: {0}" -f $Dest)
    Ok ("Chaves:  {0}" -f ($Keys -join ', '))
    Ok ("Busca:   {0} | Foco: {1}" -f ($(if($recurse){'recursiva'}else{'n√≠vel atual'}), $focus))
  } catch { Err $_.Exception.Message; return }

  $errors = 0

  if($focus -eq 'Pastas'){
    # -------- PASTAS -> copia PASTA INTEIRA (deepest) --------
    $dirEnum = if($recurse){
      Get-ChildItem -LiteralPath $Source -Directory -Recurse -Force -ErrorAction SilentlyContinue
    } else {
      Get-ChildItem -LiteralPath $Source -Directory          -Force -ErrorAction SilentlyContinue
    }
    $matched = @($dirEnum | Where-Object { $_.Name -match $Regex } | Select-Object -ExpandProperty FullName)
    $deepest = Keep-DeepestDirs $matched

    Info ("Pastas casadas (deepest): {0}" -f $deepest.Count)
    if($deepest.Count -eq 0){ Warn "Nada para copiar."; return }
    if(-not (AskYN "Prosseguir com a C√ìPIA agora?")){ Warn "Opera√ß√£o cancelada."; return }

    $RobocopyExe = Join-Path $env:SystemRoot "System32\robocopy.exe"
    $roboArgs = @('/E','/COPY:DAT','/DCOPY:T','/Z','/R:1','/W:1','/MT:16','/XJ','/NFL','/NDL','/NP')

    foreach($d in $deepest){
      try{
        $rel    = $d.Substring($Source.Length).TrimStart('\')
        $dstDir = Join-Path $Dest $rel
        if(-not (Test-Path -LiteralPath $dstDir)){ New-Item -ItemType Directory -Path $dstDir -Force | Out-Null }
        Info ("Copiando PASTA inteira: {0}" -f $d)
        $null = & $RobocopyExe $d $dstDir @roboArgs
        if($LASTEXITCODE -ge 8){
          Warn ("Robocopy falhou (ExitCode={0}) em {1}; usando Copy-Item" -f $LASTEXITCODE, $d)
          Copy-Item -LiteralPath $d -Destination $dstDir -Recurse -Force -ErrorAction Stop
        } else { Ok ("Pasta conclu√≠da: {0}" -f $d) }
      } catch { $errors++; Err ("Falha em pasta '{0}': {1}" -f $d, $_.Exception.Message) }
    }
  }
  else {
    # -------- ARQUIVOS -> copia S√ì ARQUIVOS que casam --------
    $fileEnum = if($recurse){
      Get-ChildItem -LiteralPath $Source -File -Recurse -Force -ErrorAction SilentlyContinue
    } else {
      Get-ChildItem -LiteralPath $Source -File          -Force -ErrorAction SilentlyContinue
    }
    $files = @($fileEnum | Where-Object { $_.Name -match $Regex })

    Info ("Arquivos que casam: {0}" -f $files.Count)
    if($files.Count -eq 0){ Warn "Nada para copiar."; return }
    if(-not (AskYN "Prosseguir com a C√ìPIA agora?")){ Warn "Opera√ß√£o cancelada."; return }

    foreach($f in $files){
      try{
        $rel    = $f.FullName.Substring($Source.Length).TrimStart('\')
        $subRel = Split-Path -Path $rel -Parent
        $dstDir = if([string]::IsNullOrEmpty($subRel)){ $Dest } else { Join-Path $Dest $subRel }
        if(-not (Test-Path -LiteralPath $dstDir)){ New-Item -ItemType Directory -Path $dstDir -Force | Out-Null }
        Copy-Item -LiteralPath $f.FullName -Destination $dstDir -Force -ErrorAction Stop
        Ok ("Arquivo copiado: {0}" -f $f.FullName)
      } catch { $errors++; Err ("Falha '{0}': {1}" -f $f.FullName, $_.Exception.Message) }
    }
  }

  if($errors -gt 0){ Warn ("Finalizado com {0} falha(s)." -f $errors) } else { Ok "Conclu√≠do sem falhas. üéâ" }
}

# ---------------- Programa 2: EXCLUIR ----------------
# Confirma√ß√£o simples (apenas S/N)
function Confirm-Deletion([int]$qtdPastas,[int]$qtdArquivos){
  Write-Host ""
  Write-Host ("Resumo: Pastas a apagar: {0} | Arquivos a apagar: {1}" -f $qtdPastas,$qtdArquivos) -ForegroundColor Yellow
  return (AskYN "Prosseguir com a EXCLUS√ÉO agora?")
}

function Run-Delete {
  ShowHeaderDelete

  $src = Read-Host "Informe a ORIGEM (ex.: C:\A)"
  $kw  = Read-Host "Informe as PALAVRAS-CHAVE (ex.: 1111,2222,3333)"
  $recurse = AskYN "Varrer subpastas?"
  $focus   = AskFocus 'Apagar'

  try{
    $Source = Require-Path $src "Origem"
    $Keys   = ParseKeys $kw
    $Regex  = Pattern $Keys
    Info ("Origem:  {0}" -f $Source)
    Info ("Chaves:  {0}" -f ($Keys -join ', '))
    Info ("Busca:   {0} | Foco: {1}" -f ($(if($recurse){'recursiva'}else{'n√≠vel atual'}), $focus))
  } catch { Err $_.Exception.Message; return }

  $errors = 0

  if($focus -eq 'Pastas'){
    # -------- PASTAS -> APAGA PASTA INTEIRA (deepest) --------
    $dirEnum = if($recurse){
      Get-ChildItem -LiteralPath $Source -Directory -Recurse -Force -ErrorAction SilentlyContinue
    } else {
      Get-ChildItem -LiteralPath $Source -Directory          -Force -ErrorAction SilentlyContinue
    }
    $matched = @($dirEnum | Where-Object { $_.Name -match $Regex } | Select-Object -ExpandProperty FullName)
    $deepest = Keep-DeepestDirs $matched

    Info ("Pastas casadas (deepest): {0}" -f $deepest.Count)
    if($deepest.Count -eq 0){ Warn "Nada para apagar."; return }

    if(-not (Confirm-Deletion -qtdPastas $deepest.Count -qtdArquivos 0)){
      Warn "Opera√ß√£o cancelada."; return
    }

    foreach($d in $deepest){
      try{
        Write-Host ("Apagando PASTA: {0}" -f $d)
        Remove-Item -LiteralPath $d -Recurse -Force -ErrorAction Stop
        Ok ("Pasta apagada: {0}" -f $d)
      } catch { $errors++; Err ("Falha ao apagar pasta '{0}': {1}" -f $d, $_.Exception.Message) }
    }
  }
  else {
    # -------- ARQUIVOS -> APAGA S√ì ARQUIVOS que casam --------
    $fileEnum = if($recurse){
      Get-ChildItem -LiteralPath $Source -File -Recurse -Force -ErrorAction SilentlyContinue
    } else {
      Get-ChildItem -LiteralPath $Source -File          -Force -ErrorAction SilentlyContinue
    }
    $files = @($fileEnum | Where-Object { $_.Name -match $Regex })

    Info ("Arquivos que casam: {0}" -f $files.Count)
    if($files.Count -eq 0){ Warn "Nada para apagar."; return }

    if(-not (Confirm-Deletion -qtdPastas 0 -qtdArquivos $files.Count)){
      Warn "Opera√ß√£o cancelada."; return
    }

    foreach($f in $files){
      try{
        Write-Host ("Apagando ARQUIVO: {0}" -f $f.FullName)
        Remove-Item -LiteralPath $f.FullName -Force -ErrorAction Stop
        Ok ("Arquivo apagado: {0}" -f $f.FullName)
      } catch { $errors++; Err ("Falha ao apagar '{0}': {1}" -f $f.FullName, $_.Exception.Message) }
    }
  }

  if($errors -gt 0){ Warn ("Finalizado com {0} falha(s)." -f $errors) } else { Ok "Conclu√≠do sem falhas. üéâ" }
}

# ---------------- Menu principal ----------------
do {
  try {
    ShowHeaderMain
    $opt = Read-Host "Escolha uma op√ß√£o"
    switch($opt){
      '1' { Run-Backup }
      '2' { Run-Delete }
      '0' {
           Info "Saindo..."
           Start-Sleep -Milliseconds 120
           exit 0     # fecha o processo do PowerShell
      }
      default { Warn "Op√ß√£o inv√°lida." }
    }
    if($opt -notin @('0')){
      Info "Pressione Enter para voltar ao menu..."
      [void][System.Console]::ReadLine()
    }
  } catch {
    Err ("Erro: {0}" -f $_.Exception.Message)
    Info "Pressione Enter para continuar..."
    [void][System.Console]::ReadLine()
  }
} while ($true)
# ==============================================================================
